# 第十三章 拷贝控制

拷贝构造函数
拷贝赋值运算符
移动构造函数
移动赋值运算符
析构函数destructor
*Tips:如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。*

## 13.1 拷贝构造函数

如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值

```c
class MyEditor()
{
public:
    MyEditor();                 //默认构造函数
    MyEditor(const MyEditor&);  //拷贝构造函数
private:
    string name;
    uint age;
}
```

⭐ 注意：
    变量初始化有两种方式，分别是直接初始化和拷贝初始化。
    如果使用等号（=）初始化一个变量，则执行的是拷贝初始化；不用等号的，则是直接初始化。**相对来讲，直接初始化比拷贝初始化要快。**
    ![1679652260978](image/C++_Primer笔记/1679652260978.png)
    ***拷贝初始化一定是通过拷贝构造函数或者移动构造函数，直接初始化也可能通过拷贝构造函数。***
    拷贝初始化不经在使用=定义变量时会发生，在下列情况下也会发生：
    · 将一个对象作为实参传递给一个非引用类型的形参
    · 从一个返回类型为非引用类型的函数返回一个对象
    · 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
    

## 13.2 拷贝赋值运算符
是一种运算符重载，赋值运算符通常应该返回一个指向其左侧运算对象的引用。关键字oprator=
```c
MyEditor& MyEditor::oprator=(const MyEditor editor){
    this->age = editor.age;
    this->name = editor.age;
    return *this;
}
```
小结：当没有为类定义拷贝构造函数和拷贝复制运算符时，编译器会自动生成**合成拷贝构造函数**和**合成拷贝复制运算符**，若是想阻止拷贝，可将函数定义为delete函数，即MyEditor(const MyEditor&)=delete；
## 13.3 析构函数
无论何时一个***对象被销毁***，就会自动调用其析构函数
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器（无论时标准库容器还是数组）被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁
```c
~MyEditor();
```
若类的成员变量中含有指针，且在类的构造函数中，为该指针动态分配了内存，则需要在析构函数中delete掉该指针，防止内存泄露。

## 13.4 移动构造函数
右值引用的主要应用就是重载了移动构造函数，利用了将亡值，将将亡值的空间内容交换到要拷贝的对象中。减少了深拷贝。
移动构造函数首先将传递参数的内存地址空间接管，然后将内部所有指针设置为nullptr，并且在原地址上进行新对象的构造，最后调用原对象的的析构函数，这样做既不会产生额外的拷贝开销，也不会给新对象分配内存空间。即提高程序的执行效率，节省内存消耗。
当返回值是一个局部变量时，会调用该对象的移动构造函数。
```c
Base(const Base&& base){
    this->ptr = base->ptr;
    base->ptr = nullprt;
};
```
应用实例：
```c
Base(Base&& base) {
        this->arr = base.arr;
        base.arr=nullptr;
        std::cout << "调用一次移动拷贝函数" << std::endl;
    }
Base getBase() {
    Base base(1000);//此处base是一个局部变量，是一个将亡值，在return之后会销毁
    return base;
}    
int main(){
    Base base8(getBase());//此处调用了Base的移动构造函数，将右值引用传递给base8
}
```

## 13.5 移动赋值运算符
完成和移动构造函数一样的功能
```c
Base& operator=(Base&& base) {
        this->arr = base.arr;
        std::cout << "调用一次移动赋值运算" << std::endl;
        return *this;
    }
int main(){
    Base base8；
    base8 = getBase();//此处调用了Base的移动构造函数，将右值引用传递给base8
}   
```

# 第十六章 模板与泛型编程