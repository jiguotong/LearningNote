---
title: 《图解算法》
updated: 2021-10-08T15:06:31
created: 2021-10-08T09:44:57
---

《图解算法》
2021年10月8日
9:44
《图解算法》读书笔记
1、查找
简单查找 O(n)
二分查找 O(log n)
大O表示法
2、
选择排序：遍历查找最小的一个与第一个元素交换位置，以此类推
冒泡排序：第一个与后面的一个比较大小，大的放到后面，以此类推
链表：顺序访问
数组：随机访问
3、递归
递归是自己调用自己
基线条件：函数不再调用自己，停止递归，防止死循环
递归条件：函数调用自己
调用栈（先进后出）
4、快速排序
分而治之
快速排序(注意判断条件，否则极易出错)
最佳情况
最糟情况
5、散列表
理想散列表（哈希表）是一个包含**关键字**的具有固定大小的数组，它能够以常数时间执行插入，删除和查找操作。
键——值
散列函数很重要：避免不必要的冲突
填装因子：占用个数/总位置个数
6、广度优先搜索
解决**最短路径问题**的算法被称为广度优先搜索
广度有限搜素：先搜索一度关系，再搜索二度关系，直到找出目标元素，对于检查过的人，务必不要再去检查，否则可能导致无限循环。
运用队列结构，压入弹出
\*\*\*\*\*\*\*\*二维vector的初始化方式\*\*\*\*\*记得分配空间\*\*
matrix.resize(row);
for (int i = 0; i \< row; i++) // 邻接矩阵初始化

matrix\[i\].resize(col);

for (int i = 0; i \< row; i++)

for (int j = 0; j \< col; j++)

matrix\[i\]\[j\] = 0;
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*
\*\*\*\*\*\*\*\*\*template\<class T\>\*\*\*\*\*\*
==使用类模板时，不支持在cpp中实现成员函数，一般在.h中实现==
\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*\*

==7、迪杰斯特拉算法==Dijkstra单源最短路径问题
权重
狄克斯特拉算法只适用于有向无环图
<https://blog.csdn.net/qq_35644234/article/details/60870719>Dijkstra算法C++实现（手写实现一遍）

8、贪婪算法
\*就是你每步都选择局部最优解，最终得到的就是全局最优解
\*贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。
\*对于NP完全问题，还没有找到快速解决方案。
\*面临NP完全问题时，最佳的做法是使用近似算法。
\*贪婪算法易于实现、运行速度快，是不错的近似算法。

9、动态规划
1、问题的答案依赖于问题的规模​，也就是问题的所有答案构成了一个数列。
2、大规模问题的答案可以由小规模问题的答案递推得到。
动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必
须在背包容量给定的情况下，偷到价值最高的商品。

&：动态规划算法与分治法类似，其基本思想就是将待求解问题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合动态规划法求解的问题，经分解得到的子问题往往不是相互独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，以至于最后解决原问题需要耗费指数时间。然而，不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复结算了很多次。如果我们能够保存已经解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，从而得到多项式时间复杂度的算法。为了达到次目的，可以用一个表来记录所有已解决的子问题的答案，不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思想。你是最棒的！！！
将待求解问题分解成若干子问题，先求解子问题，然后从这些子问题的解得到原问题的解；经分解得到的子问题往往不是相互独立的；保存已经解决的子问题的答案，避免重复计算。

10、K最近邻算法
K近邻算法（KNN）是一种常用的==分类==和==回归==方法，它的基本思想是从训练集中寻找和输入样本最相似的k个样本，如果这k个样本中的大多数属于某一个类别，则输入的样本也属于这个类别。
**机器学习 训练样本**

OVER!

